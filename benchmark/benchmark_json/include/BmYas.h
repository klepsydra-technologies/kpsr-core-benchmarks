#ifndef BMYAS_H
#define BMYAS_H

#include <benchmark/benchmark.h>
#include <VectorFloatStruct4Yas.h>
#include <yas/serialize.hpp>
#include <yas/std_types.hpp>


namespace bmrkYas {
class BmYas
{
public:
    // ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- 
    // WARNING: Detected deserialized float value has less decimals than original one.
    // Original:     2.90683093e+38
    // Deserialized: 2.90683079
    // ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- 
    static void DeserializeFromJsonMemoryBufferToVector(benchmark::State &state)
    {
        try{
            long vectorSize = state.range(0);
            std::string filename = {JSON_FILE_PATH_AND_NAME + std::to_string(vectorSize)};      // WARNING: Precompiler variable created through root CMakeLists file.
            size_t retrievedVectorSize = 0;
            yas::shared_buffer json_Yasbuffer;
            
            VectorFloatStruct4Cereal deserializedVectorCereal;                                  // Use Cereal to load from disk.
            deserializedVectorCereal.deserializeJsonFileToVector(filename); 
            
            VectorFloatStruct4Yas vecYasInitialConditions;
            vecYasInitialConditions.loadFrom(deserializedVectorCereal.getVec());                // Load initial conditions from previous Cereal load.
        
            // 1o obtain jsonMemoryBuffer.
            json_Yasbuffer = vecYasInitialConditions.serializeVectorToJson();

            VectorFloatStruct4Yas deserializedVectorYas;                                        // Create an empty vector to load results;
            for (auto _ : state) 
            {
                deserializedVectorYas.deserializeJsonToVector(json_Yasbuffer);
            }

            retrievedVectorSize = deserializedVectorYas.getSize();
            state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(retrievedVectorSize * sizeof(float)));
            state.counters["retrievedVectorSz"] = retrievedVectorSize;

        }catch(...) {
            std::cerr << "Controller exception in DeserializeFromJsonMemoryBufferToVector(): "  
                << std::endl; 
        }
    }




    // ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- 
    // Pre: fileName to be loaded, must be created previously with same structure as
    //      expected. {"vector":[2.9289584319718135e37,1.6839896504033476e38, ..
    // ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- 
    static void DeserializeFromJsonFileToVector(benchmark::State &state)
    {
        try{
            long vectorSize = state.range(0);
            std::string filename = {JSON_FILE_PATH_AND_NAME + std::to_string(vectorSize)};      // WARNING: Precompiler variable created through root CMakeLists file.
            size_t retrievedVectorSize = 0;
            
            VectorFloatStruct4Yas deserializedVectorYas;                                        // Create an empty vector to load results;
            for (auto _ : state) 
            {
                deserializedVectorYas.deserializeJsonFileToVector(filename);
            }

            retrievedVectorSize = deserializedVectorYas.getSize();
            state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(retrievedVectorSize * sizeof(float)));
            state.counters["retrievedVectorSz"] = retrievedVectorSize;

        }catch(...) {
            std::cerr << "Controller exception in DeserializeFromJsonFileToVector(): "  
                << std::endl; 
        }
    }




    // ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- 
    // Pre: Yas seems requires bin file must be the one generated by yas.
    // Post:We get float values for initial conditions from previous cereal file.
    //      These values are used to load yas vector which will be used to generate
    //      yas binary file.
    //      This yas binary file will be used as input to benchmark deserialization.
    // ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- 
    static void DeserializeFromBinaryFileToVector(benchmark::State &state)
    {
        try{
            long vectorSize = state.range(0);
            std::string filename = {JSON_FILE_PATH_AND_NAME + std::to_string(vectorSize) + "_bin"}; // WARNING: Precompiler variable created through root CMakeLists file.
            size_t retrievedVectorSize = 0;
                    
            VectorFloatStruct4Cereal deserializedVectorCereal;                                      // Use Cereal to load from disk.
            deserializedVectorCereal.deserializeBinaryFileToVector(filename); 
                    
            std::string fileNameYas = {JSON_FILE_PATH_AND_NAME + 
                std::to_string(vectorSize) + "_yas_bin"};
            VectorFloatStruct4Yas vecYasInitialConditions;
            vecYasInitialConditions.loadFrom(deserializedVectorCereal.getVec());
            vecYasInitialConditions.serializeVectorToBinaryFile(fileNameYas);

            VectorFloatStruct4Yas deserializedVectorYas;                                            // Create an empty vector to load results;
            for (auto _ : state) 
            {
                deserializedVectorYas.deserializeBinaryFileToVector(fileNameYas);
            }

            retrievedVectorSize = deserializedVectorYas.getSize();
            state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(retrievedVectorSize * sizeof(float)));
            state.counters["retrievedVectorSz"] = retrievedVectorSize;

        }catch(...) {
            std::cerr << "Controller exception in DeserializeFromBinaryFileToVector(): "  
                << std::endl; 
        }
    }




    // ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- 
    // SetBytesProcessed() in terms of float bytes conatined in retrieved vector
    // NOT in terms of json binary bytes. 
    // ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- 
    static void DeserializeFromBinaryStreamToVector(benchmark::State &state)
    {
        try{
            long vectorSize = state.range(0);
            std::string filename = {JSON_FILE_PATH_AND_NAME + std::to_string(vectorSize) + "_bin"}; // WARNING: Precompiler variable created through root CMakeLists file.
            size_t retrievedVectorSize = 0;
                    
            VectorFloatStruct4Cereal deserializedVectorCereal;                                      // Use Cereal to load from disk.
            deserializedVectorCereal.deserializeBinaryFileToVector(filename); 
                    
            VectorFloatStruct4Yas vecYasInitialConditions;
            vecYasInitialConditions.loadFrom(deserializedVectorCereal.getVec());
            yas::shared_buffer streamBuffer = vecYasInitialConditions.serializeVectorToBinaryStream();

            VectorFloatStruct4Yas deserializedVectorYas;                                    // Create an empty vector to load results;
            for (auto _ : state) 
            {
                deserializedVectorYas.deserializeBinaryStreamToVector(streamBuffer);
            }
            
            retrievedVectorSize = deserializedVectorYas.getSize();
            state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(retrievedVectorSize * sizeof(float)));
            state.counters["retrievedVectorSz"] = retrievedVectorSize;

        }catch(...) {
            std::cerr << "Controller exception in DeserializeFromBinaryStreamToVector(): "  
                << std::endl; 
        }
    }

}; // end class BmPods.
}// end namespace.


#endif // BMPODS_H
